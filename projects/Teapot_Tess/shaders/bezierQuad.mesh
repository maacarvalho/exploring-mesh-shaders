#version 460
#extension GL_NV_mesh_shader : enable
 
layout(local_size_x=32) in;
layout(triangles, max_vertices=256, max_primitives=512) out;
//layout(points, max_vertices=256, max_primitives=512) out;

taskNV in perTaskData {
  uint divs;
  uint patch_id;
};

perprimitiveNV out PerPrimitiveData 
{
  uint no_meshlets;
  uint meshlet_id;
} p_out[]; 

//out perVertexData {

    //vec3 normalTE;
    //vec2 texCoordTE;

//} v_out[];

uniform mat4 m_pvm;
uniform	mat3 normalMatrix;

uniform vec3 disp;

uniform float level;

layout(std430, binding = 1) readonly buffer patchesBuffer
{
    uint patches[];
};

layout(std430, binding = 2) readonly buffer verticesBuffer
{
    vec4 vertices[];
};

mat4 M = mat4(vec4(-1, 3, -3, 1), vec4(3, -6, 3, 0), vec4 (-3, 3, 0, 0), vec4(1 ,0, 0, 0));

void emit_point (int patch_id, float u, float v, uint idx) 
{

    vec4 p00 = vertices[patches[patch_id * 16 +  0]];
	vec4 p10 = vertices[patches[patch_id * 16 +  1]];
	vec4 p20 = vertices[patches[patch_id * 16 +  2]];
	vec4 p30 = vertices[patches[patch_id * 16 +  3]];
	vec4 p01 = vertices[patches[patch_id * 16 +  4]];
	vec4 p11 = vertices[patches[patch_id * 16 +  5]];
	vec4 p21 = vertices[patches[patch_id * 16 +  6]];
	vec4 p31 = vertices[patches[patch_id * 16 +  7]];
	vec4 p02 = vertices[patches[patch_id * 16 +  8]];
	vec4 p12 = vertices[patches[patch_id * 16 +  9]];
	vec4 p22 = vertices[patches[patch_id * 16 + 10]];
	vec4 p32 = vertices[patches[patch_id * 16 + 11]];
	vec4 p03 = vertices[patches[patch_id * 16 + 12]];
	vec4 p13 = vertices[patches[patch_id * 16 + 13]];
	vec4 p23 = vertices[patches[patch_id * 16 + 14]];
	vec4 p33 = vertices[patches[patch_id * 16 + 15]];
	

	vec4 U = vec4(u*u*u, u*u, u, 1);
	vec4 V = vec4(v*v*v, v*v, v, 1);
	vec4 du = vec4( 3 * U.y, 2 * u, 1, 0);
	vec4 dv = vec4( 3 * V.y, 2 * v, 1, 0);

	mat4 Px = mat4( p00.x, p10.x, p20.x, p30.x, p01.x, p11.x, p21.x, p31.x, p02.x, p12.x, p22.x, p32.x, p03.x, p13.x, p23.x, p33.x);
	mat4 Py = mat4( p00.y, p10.y, p20.y, p30.y, p01.y, p11.y, p21.y, p31.y, p02.y, p12.y, p22.y, p32.y, p03.y, p13.y, p23.y, p33.y);
	mat4 Pz = mat4( p00.z, p10.z, p20.z, p30.z, p01.z, p11.z, p21.z, p31.z, p02.z, p12.z, p22.z, p32.z, p03.z, p13.z, p23.z, p33.z);

	vec4 res;

/*  
 // Versão baseada em multiplicação de matrizes
	mat4 MPxM = M *	Px * M;
	mat4 MPyM = M *	Py * M;
	mat4 MPzM = M *	Pz * M;

	res.x = dot  (U, MPxM * V);
	res.z = -dot (U, MPyM * V);
	res.y = dot  (U, MPzM * V);
	res.w = 1;

	vec3 dpdu;
	dpdu.x = dot  (du, MPxM * V);
	dpdu.z = -dot (du, MPyM * V);
	dpdu.y = dot  (du, MPzM * V);

	vec3 dpdv;
	dpdv.x = dot  (U, MPxM * dv);
	dpdv.z = -dot (U, MPyM * dv);
	dpdv.y = dot  (U, MPzM * dv);
 */
 
// versão que só multiplica matrizes por vectores
	vec4 MV = M * V;
	vec4 MPxMV = M * (Px * MV);
	vec4 MPyMV = M * (Py * MV);
	vec4 MPzMV = M * (Pz * MV);
	res.x = dot(U , MPxMV);
	res.z = -dot(U , MPyMV);
	res.y = dot(U , MPzMV);
	res.w =  1;

	vec3 dpdu;
	dpdu.x = dot (du, MPxMV);
	dpdu.z = -dot (du, MPyMV);
	dpdu.y = dot (du, MPzMV);


	vec3 dpdv;
	MV = M * dv;
	MPxMV = M * (Px * MV);
	MPyMV = M * (Py * MV);
	MPzMV = M * (Pz * MV);
	dpdv.x = dot (U, MPxMV);
	dpdv.z = -dot (U, MPyMV);
	dpdv.y = dot (U, MPzMV);
	 
    gl_MeshVerticesNV[idx].gl_Position = m_pvm * vec4(disp + res.xyz, 1.0);
    //v_out[idx].normalTE = normalize(normalMatrix * cross( dpdu.xyz, dpdv.xyz ));
    //v_out[idx].texCoordTE = vec2(u,v);
    
}

void main()
{
   
    //int ceil_lvl = int(ceil(level));
    //for (int i=0; i<=ceil_lvl; i++) {

        //for (int j=0; j<=ceil_lvl; j++) {

            //emit_point (i / float(ceil_lvl), j / float(ceil_lvl), i * ceil_lvl + j);
            ////if (i != 0 && j != 0) {

                //gl_PrimitiveIndicesNV[(i * ceil_lvl + j)] = i * ceil_lvl + j;
                ////gl_PrimitiveIndicesNV[2 * (i * ceil_lvl + j) + 1] = i * ceil_lvl + j;

    
        //}
    //}

    //gl_PrimitiveCountNV = ceil_lvl * ceil_lvl;

    //uint workg_id = gl_WorkGroupID.x;
    //for (int i=0; i<16; i++) {

        //gl_MeshVerticesNV[i].gl_Position = m_pvm * vertices[patches[workg_id * 16 + i]];

    //}

    //for (int i=0; i<15; i++) {
        
        //gl_PrimitiveIndicesNV[i * 2 + 0] = i;
        //gl_PrimitiveIndicesNV[i * 2 + 1] = i + 1;
    //}

    //gl_PrimitiveCountNV = 16;

    // Inputs
    uint local_id  = gl_LocalInvocationID.x;
    uint global_id  = gl_GlobalInvocationID.x;
    uint workg_id = gl_WorkGroupID.x;
    uint workg_len = gl_WorkGroupSize.x;

    // Tessellation Levels
    int ceil_odd = int(ceil(level));
    ceil_odd += ceil_odd % 2;

    // Quad vertices
    vec4 v0 = vec4(disp + vec3 (-1, -1, 0), 1.0);
    vec4 v1 = vec4(disp + vec3 (1, -1, 0), 1.0);
    vec4 v2 = vec4(disp + vec3 (1, 1, 0), 1.0);
    vec4 v3 = vec4(disp + vec3 (-1, 1, 0), 1.0);

    //int patch_id  = int(workg_id / (divs * divs));
    int divs_u_id = int(workg_id % divs);
    int divs_v_id = int(workg_id / divs);

    int min_u_idx = int(max( 0.0, round( mix( 0.0, float(ceil_odd), float(divs_u_id) / float(divs)))));
    int max_u_idx = int(min( ceil_odd, round( mix( 0.0, float(ceil_odd), float(divs_u_id + 1) / float(divs)))));
    int min_v_idx = int(max( 0.0, round( mix( 0.0, float(ceil_odd), float(divs_v_id) / float(divs)))));
    int max_v_idx = int(min( ceil_odd, round( mix( 0.0, float(ceil_odd), float(divs_v_id + 1) / float(divs)))));

    int no_cols = max_u_idx - min_u_idx;
    int no_lines = max_v_idx - min_v_idx;
    int no_verts = (no_cols + 1) * (no_lines + 1);

    for (int i=0; i <= no_verts / workg_len; i++) {

        int idx = int(min(i * workg_len + local_id, no_verts - 1));

        int u_idx = min_u_idx + idx % int(no_cols + 1);
        int v_idx = min_v_idx + idx / int(no_cols + 1);

        uint prev_u_idx = u_idx - 1 - int(u_idx == ceil_odd) * 1 + int(u_idx == 0) * 1;
        uint prev_v_idx = v_idx - 1 - int(v_idx == ceil_odd) * 1 + int(v_idx == 0) * 1;

        float u = float(u_idx) / float(ceil_odd);
        float prev_u = float(prev_u_idx) / float(max(1, ceil_odd - 2));
        float v = float(v_idx) / float(ceil_odd);
        float prev_v = float(prev_v_idx) / float(max(1, ceil_odd - 2));

        float inter_u = mix (prev_u, u, 1 - int(level >= 2) * 0.5 * (ceil_odd - level));
        float inter_v = mix (prev_v, v, 1 - int(level >= 2) * 0.5 * (ceil_odd - level));

        //gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(mix(v0, v1, u), mix(v3, v2, u), v);
        //gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(mix(v0, v1, prev_u), mix(v3, v2, prev_u), prev_v);
        //gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(mix(v0, v1, inter_u), mix(v3, v2, inter_u), inter_v);
        //gl_PrimitiveIndicesNV[idx] = idx;

        emit_point(int(patch_id), inter_u, inter_v, idx);
        //gl_PrimitiveIndicesNV[idx] = idx;
        //p_out[idx].meshlet_id = patch_id;
        //p_out[idx].no_meshlets = divs;
    }

    int no_prims = (no_cols) * (no_lines) * 2;

    for (int i=0; i <= no_prims / workg_len; i++) {

        int idx = int(min(i * workg_len + local_id, no_prims - 1));

        int u_idx = (idx / 2) % (no_cols);
        int v_idx = (idx / 2) / (no_cols);

        gl_PrimitiveIndicesNV[idx * 3 + 0] = v_idx * (no_cols + 1) + u_idx;
        gl_PrimitiveIndicesNV[idx * 3 + 1] = (v_idx + 1 * idx % 2) * (no_cols + 1) + u_idx + 1;
        gl_PrimitiveIndicesNV[idx * 3 + 2] = (v_idx + 1) * (no_cols + 1) + u_idx + 1 * (1 - idx % 2);

        //p_out[idx].meshlet_id = patch_id;
        //p_out[idx].no_meshlets = 32;

        //p_out[idx].meshlet_id = workg_id;
        //p_out[idx].no_meshlets = divs * divs;

        p_out[idx].meshlet_id = (patch_id + 1) * divs * divs + workg_id;
        p_out[idx].no_meshlets = 32 * divs * divs;

    }

    // No. Primitives
    gl_PrimitiveCountNV = no_prims;

}
