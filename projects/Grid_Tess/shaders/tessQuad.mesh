#version 460
#extension GL_NV_mesh_shader : enable
 
layout(local_size_x=32) in;
layout(triangles, max_vertices=256, max_primitives=512) out;

uniform mat4 m_pvm;

uniform vec3 disp;

uniform float level;

layout(std430, binding = 1) readonly buffer verticesBuffer
{
    float vertices[];
};

void main()
{
    // Inputs
    uint local_id  = gl_LocalInvocationID.x;
    uint global_id  = gl_GlobalInvocationID.x;
    uint workg_id = gl_WorkGroupID.x;
    uint workg_len = gl_WorkGroupSize.x;

    // Tessellation Levels
    int ceil_odd = int(ceil(level));
    ceil_odd += 1 - ceil_odd % 2;

    // Quad vertices
    int v0_idx = 0 * 3;
    int v1_idx = 1 * 3;
    int v2_idx = 2 * 3;
    int v3_idx = 3 * 3;
    
    vec4 v0 = vec4(disp + vec3 (vertices[v0_idx + 1], 
                                vertices[v0_idx + 2], 
                                vertices[v0_idx + 3]), 1.0);
    vec4 v1 = vec4(disp + vec3 (vertices[v1_idx + 1], 
                                vertices[v1_idx + 2], 
                                vertices[v1_idx + 3]), 1.0);
    vec4 v2 = vec4(disp + vec3 (vertices[v2_idx + 1], 
                                vertices[v2_idx + 2], 
                                vertices[v2_idx + 3]), 1.0);
    vec4 v3 = vec4(disp + vec3 (vertices[v3_idx + 1], 
                                vertices[v3_idx + 2], 
                                vertices[v3_idx + 3]), 1.0);

    int no_verts = (ceil_odd + 1) * (ceil_odd + 1);

    for (int i=0; i <= no_verts / workg_len; i++) {

        int idx = int(min(i * workg_len + local_id, no_verts - 1));

        int u_idx = idx % int(ceil_odd + 1);
        int v_idx = idx / int(ceil_odd + 1);

        int prev_u_idx = u_idx - 1 * int(abs(u_idx - ceil_odd / 2.0 ) < 1) - 2 * int(u_idx - ceil_odd / 2.0 > 1);
        int prev_v_idx = v_idx - 1 * int(abs(v_idx - ceil_odd / 2.0 ) < 1) - 2 * int(v_idx - ceil_odd / 2.0 > 1);

        float u = float(u_idx) / float(ceil_odd);
        float prev_u = float(prev_u_idx) / float(ceil_odd - 2);
        float v = float(v_idx) / float(ceil_odd);
        float prev_v = float(prev_v_idx) / float(ceil_odd - 2);

        float inter_u = mix (prev_u, u, 1 - 0.5 * (ceil_odd - level));
        float inter_v = mix (prev_v, v, 1 - 0.5 * (ceil_odd - level));

        gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(mix(v0, v1, inter_u), mix(v3, v2, inter_u), inter_v);

    }

    int no_prims = ceil_odd * ceil_odd * 2;

    for (int i=0; i <= no_prims / workg_len; i++) {

        int idx = int(min(i * workg_len + local_id, no_prims - 1));

        int u_idx = (idx / 2) % ceil_odd;
        int v_idx = (idx / 2) / ceil_odd;

        gl_PrimitiveIndicesNV[idx * 3 + 0] = v_idx * (ceil_odd + 1) + u_idx;
        gl_PrimitiveIndicesNV[idx * 3 + 1] = (v_idx + 1 * idx % 2) * (ceil_odd + 1) + u_idx + 1;
        gl_PrimitiveIndicesNV[idx * 3 + 2] = (v_idx + 1) * (ceil_odd + 1) + u_idx + 1 * (1 - idx % 2);

    }

    // No. Primitives
    gl_PrimitiveCountNV = 512;

}
