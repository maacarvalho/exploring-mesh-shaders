#version 460
#extension GL_NV_mesh_shader : enable
 
layout(local_size_x=32) in;
layout(triangles, max_vertices=256, max_primitives=512) out;

taskNV in perTaskData {
  uint divs;
};

perprimitiveNV out PerPrimitiveData 
{
  uint divs;
  uint mesh_id;
} p_out[]; 

uniform mat4 m_pvm;

uniform vec3 disp;

uniform float level;

layout(std430, binding = 1) readonly buffer verticesBuffer
{
    float vertices[];
};

void main()
{
    // Inputs
    uint local_id  = gl_LocalInvocationID.x;
    uint global_id  = gl_GlobalInvocationID.x;
    uint workg_id = gl_WorkGroupID.x;
    uint workg_len = gl_WorkGroupSize.x;


    // Tessellation Levels
    int ceil_odd = int(ceil(level));
    ceil_odd += ceil_odd % 2;

    // Quad vertices
    vec4 v0 = vec4(disp + vec3 (vertices[0 * 3 + 1], 
                                vertices[0 * 3 + 2], 
                                vertices[0 * 3 + 3]), 1.0);
    vec4 v1 = vec4(disp + vec3 (vertices[1 * 3 + 1], 
                                vertices[1 * 3 + 2], 
                                vertices[1 * 3 + 3]), 1.0);
    vec4 v2 = vec4(disp + vec3 (vertices[2 * 3 + 1], 
                                vertices[2 * 3 + 2], 
                                vertices[2 * 3 + 3]), 1.0);
    vec4 v3 = vec4(disp + vec3 (vertices[3 * 3 + 1], 
                                vertices[3 * 3 + 2], 
                                vertices[3 * 3 + 3]), 1.0);

    int workg_u_id = int(workg_id % divs);
    int workg_v_id = int(workg_id / divs);

    int min_u_idx = int(max( 0.0, round( mix( 0.0, float(ceil_odd), float(workg_u_id) / float(divs)))));
    int max_u_idx = int(min( ceil_odd, round( mix( 0.0, float(ceil_odd), float(workg_u_id + 1) / float(divs)))));
    int min_v_idx = int(max( 0.0, round( mix( 0.0, float(ceil_odd), float(workg_v_id) / float(divs)))));
    int max_v_idx = int(min( ceil_odd, round( mix( 0.0, float(ceil_odd), float(workg_v_id + 1) / float(divs)))));

    int no_cols = max_u_idx - min_u_idx;
    int no_lines = max_v_idx - min_v_idx;
    int no_verts = (no_cols + 1) * (no_lines + 1);

    for (int i=0; i <= no_verts / workg_len; i++) {

        int idx = int(min(i * workg_len + local_id, no_verts - 1));

        int u_idx = min_u_idx + idx % int(no_cols + 1);
        int v_idx = min_v_idx + idx / int(no_cols + 1);

        uint prev_u_idx = u_idx - 1 - int(u_idx == ceil_odd) * 1 + int(u_idx == 0) * 1;
        uint prev_v_idx = v_idx - 1 - int(v_idx == ceil_odd) * 1 + int(v_idx == 0) * 1;

        float u = float(u_idx) / float(ceil_odd);
        float prev_u = float(prev_u_idx) / float(max(1, ceil_odd - 2));
        float v = float(v_idx) / float(ceil_odd);
        float prev_v = float(prev_v_idx) / float(max(1, ceil_odd - 2));

        float inter_u = mix (prev_u, u, 1 - int(level >= 2) * 0.5 * (ceil_odd - level));
        float inter_v = mix (prev_v, v, 1 - int(level >= 2) * 0.5 * (ceil_odd - level));

        //gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(mix(v0, v1, u), mix(v3, v2, u), v);
        //gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(mix(v0, v1, prev_u), mix(v3, v2, prev_u), prev_v);
        gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(mix(v0, v1, inter_u), mix(v3, v2, inter_u), inter_v);
        //gl_PrimitiveIndicesNV[idx] = idx;

        //p_out[idx].mesh_id = workg_id;
        //p_out[idx].divs = divs;
    }

    //gl_MeshVerticesNV[0].gl_Position = m_pvm * mix( 
            //mix (v0, v1, float(min_u_idx) / float(ceil_odd)),
            //mix (v3, v2, float(min_u_idx) / float(ceil_odd)),
            //float(min_v_idx) / float(ceil_odd));

    //gl_MeshVerticesNV[1].gl_Position = m_pvm * mix( 
            //mix (v0, v1, float(max_u_idx) / float(ceil_odd)),
            //mix (v3, v2, float(max_u_idx) / float(ceil_odd)),
            //float(min_v_idx) / float(ceil_odd));

    //gl_MeshVerticesNV[2].gl_Position = m_pvm * mix( 
            //mix (v0, v1, float(max_u_idx) / float(ceil_odd)),
            //mix (v3, v2, float(max_u_idx) / float(ceil_odd)),
            //float(max_v_idx) / float(ceil_odd));

    //gl_MeshVerticesNV[3].gl_Position = m_pvm * mix( 
            //mix (v0, v1, float(min_u_idx) / float(ceil_odd)),
            //mix (v3, v2, float(min_u_idx) / float(ceil_odd)),
            //float(max_v_idx) / float(ceil_odd));

    //gl_PrimitiveIndicesNV[0] = 0;
    //gl_PrimitiveIndicesNV[1] = 1;
    //gl_PrimitiveIndicesNV[2] = 2;
    //gl_PrimitiveIndicesNV[3] = 0;
    //gl_PrimitiveIndicesNV[4] = 2;
    //gl_PrimitiveIndicesNV[5] = 3;

    //p_out[0].mesh_id = workg_id;
    //p_out[0].divs = divs;
    //p_out[1].mesh_id = workg_id;
    //p_out[1].divs = divs;

    int no_prims = (no_cols) * (no_lines) * 2;

    for (int i=0; i <= no_prims / workg_len; i++) {

        int idx = int(min(i * workg_len + local_id, no_prims - 1));

        int u_idx = (idx / 2) % (no_cols);
        int v_idx = (idx / 2) / (no_cols);

        gl_PrimitiveIndicesNV[idx * 3 + 0] = v_idx * (no_cols + 1) + u_idx;
        gl_PrimitiveIndicesNV[idx * 3 + 1] = (v_idx + 1 * idx % 2) * (no_cols + 1) + u_idx + 1;
        gl_PrimitiveIndicesNV[idx * 3 + 2] = (v_idx + 1) * (no_cols + 1) + u_idx + 1 * (1 - idx % 2);

        p_out[idx].mesh_id = workg_id;
        p_out[idx].divs = divs;

    }

    // No. Primitives
    gl_PrimitiveCountNV = 512;

}
