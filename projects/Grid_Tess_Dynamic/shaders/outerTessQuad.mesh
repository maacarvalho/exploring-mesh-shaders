#version 460
#extension GL_NV_mesh_shader : enable
 
layout(local_size_x=32) in;
//layout(triangles, max_vertices=16, max_primitives=16) out;
layout(triangles, max_vertices=256, max_primitives=512) out;
//layout(lines, max_vertices=4, max_primitives=4) out;
//layout(points, max_vertices=4, max_primitives=4) out;

taskNV in perTaskData {
  uint left_divs;
  uint bottom_divs;
  uint right_divs;
  uint top_divs;
};

perprimitiveNV out PerPrimitiveData 
{
  uint divs;
  uint mesh_id;
} p_out[]; 

//out perVertexData
//{
    //vec2 texCoordTE;
//} v_out[];

uniform mat4 m_pvm;

uniform vec3 disp;

uniform float iRows;
uniform float iCols;

uniform float oLeft;
uniform float oBottom;
uniform float oRight;
uniform float oTop;

layout(std430, binding = 1) readonly buffer verticesBuffer
{
    float vertices[];
};

void main()
{
    // Inputs
    uint local_id  = gl_LocalInvocationID.x;
    uint global_id  = gl_GlobalInvocationID.x;
    uint workg_id = gl_WorkGroupID.x;
    uint workg_len = gl_WorkGroupSize.x;

    uint divs[] =  {bottom_divs, right_divs,top_divs, left_divs};

    uint side_wg_id = workg_id, side_id = 0;
    for(; side_wg_id >= divs[side_id]; side_id++) side_wg_id -= divs[side_id];

    //if (side_id != 0) return;
    
    // Quad vertices
    vec4 v0 = vec4(disp + vec3 (vertices[((side_id + 0) % 4) * 3 + 1], 
                                vertices[((side_id + 0) % 4) * 3 + 2], 
                                vertices[((side_id + 0) % 4) * 3 + 3]), 1.0);
    vec4 v1 = vec4(disp + vec3 (vertices[((side_id + 1) % 4) * 3 + 1], 
                                vertices[((side_id + 1) % 4) * 3 + 2], 
                                vertices[((side_id + 1) % 4) * 3 + 3]), 1.0);
    vec4 v2 = vec4(disp + vec3 (vertices[((side_id + 2) % 4) * 3 + 1], 
                                vertices[((side_id + 2) % 4) * 3 + 2], 
                                vertices[((side_id + 2) % 4) * 3 + 3]), 1.0);
    vec4 v3 = vec4(disp + vec3 (vertices[((side_id + 3) % 4) * 3 + 1], 
                                vertices[((side_id + 3) % 4) * 3 + 2], 
                                vertices[((side_id + 3) % 4) * 3 + 3]), 1.0);

    // Side Tessellation Levels and Divisions
    float oLvls[] = {oBottom, oRight, oTop, oLeft};
    float iLvls[] = {iCols, iRows, iCols, iRows};

    // Current side Tessellation Levels
    float oLvl = oLvls[side_id];
    float iuLvl = iLvls[side_id];
    float ivLvl = iLvls[(side_id + 1) % 4];

    int ceil_oLvl = int(ceil(oLvl));
    ceil_oLvl += ceil_oLvl % 2;
    int ceil_iuLvl = int(ceil(iuLvl));
    ceil_iuLvl += ceil_iuLvl % 2;
    int ceil_ivLvl = int(ceil(ivLvl));
    ceil_ivLvl += ceil_ivLvl % 2;

    double down_min = double(ceil_oLvl) * double(side_wg_id) / double(divs[side_id]);
    double down_max = double(ceil_oLvl) * double(side_wg_id + 1) / double(divs[side_id]);
    double top_min = 1.0 + double(ceil_iuLvl - 2) * double(side_wg_id) / double(divs[side_id]);
    double top_max = 1.0 + double(ceil_iuLvl - 2) * double(side_wg_id + 1) / double(divs[side_id]);

    int min_u_down = int(max( 0.0, int( side_wg_id >= double(divs[side_id]) * 0.5 ) * round( down_min ) + 
                                   int( side_wg_id < double(divs[side_id]) * 0.5 ) * round( down_min )));
    int max_u_down = int(max( 0.0, int( side_wg_id + 1 >= double(divs[side_id]) * 0.5 ) * round( down_max ) + 
                                   int( side_wg_id + 1 < double(divs[side_id]) * 0.5 ) * round( down_max )));
    int min_u_top = int(max( 0.0, int( side_wg_id >= double(divs[side_id]) * 0.5 ) * round( top_min ) + 
                                  int( side_wg_id < double(divs[side_id]) * 0.5 ) * round( top_min )));
    int max_u_top = int(max( 0.0, int( side_wg_id + 1 >= double(divs[side_id]) * 0.5 ) * round( top_max ) + 
                                  int( side_wg_id + 1 < double(divs[side_id]) * 0.5 ) * round( top_max )));

    int no_bottom_verts = max_u_down - min_u_down + 1;
    int no_top_verts = max_u_top - min_u_top + 1;
    int no_verts = no_bottom_verts + no_top_verts;

    //if (side_wg_id != 0) return;
    
    int top_divergent_idx = ceil_iuLvl - 2 - int(pow(2, floor(log2(ceil_iuLvl - 2)))) + 1;
    int bot_divergent_idx = ceil_oLvl - 2 - int(pow(2, floor(log2(ceil_oLvl - 2)))) + 1;

    double log_oLvl = log2(ceil_oLvl);
    double log_iuLvl = log2(ceil_iuLvl);

    for (int i=0; i <= no_verts / workg_len; i++) {

        int idx = int(min(i * workg_len + local_id, no_verts - 1));

        int is_down = int(idx < no_bottom_verts), is_up = int(idx >= no_bottom_verts);

        int min_u_idx = is_down * min_u_down + is_up * min_u_top;

        int u_idx = min_u_idx + idx - is_up * no_bottom_verts; 
        int v_idx = is_down * 0 + is_up * 1;

        double lvl = is_down * oLvl + is_up * iuLvl;
        int ceil_lvl = is_down * ceil_oLvl + is_up * ceil_iuLvl;

        uint dup_prev_u_idx = is_down * bot_divergent_idx + is_up * top_divergent_idx; 

        uint prev_u_idx = max(is_up, min(ceil_lvl - 2 - is_up, u_idx -
                    int(u_idx > dup_prev_u_idx) - int(u_idx >= ceil_lvl - dup_prev_u_idx)));
        uint prev_v_idx = is_up;

        //uint prev_u_idx = max(is_up, min(ceil_lvl - 2 - is_up, int(round(
                            //(ceil_lvl - 2) * double(u_idx) / double(ceil_lvl)))));
        //uint prev_v_idx = max(is_up, min(ceil_ivLvl - 2 - is_up, int(round(
                            //(ceil_ivLvl - 2) * double(v_idx) / double(ceil_ivLvl)))));
        //uint prev_u_idx = u_idx - 1 - int(u_idx == ceil_lvl - is_up) * 1 + int(u_idx == is_up) * 1;
        //uint prev_v_idx = v_idx - 1 - int(v_idx == ceil_ivLvl - 1) * 1 + int(v_idx == 1) * 1;

        double u = double(u_idx) / double(ceil_lvl);
        double prev_u = double(prev_u_idx) / double(max(1, ceil_lvl - 2));
        double v = double(v_idx) / double(ceil_ivLvl);
        double prev_v = double(prev_v_idx) / double(max(1, ceil_ivLvl - 2));

        double inter_u = mix (prev_u, u, 1 - int(lvl >= 2) * 0.5 * (ceil_lvl - lvl));
        double inter_v = mix (prev_v, v, 1 - is_up * (int(ivLvl >= 2) * 0.5 * (ceil_ivLvl - ivLvl)));

        //gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(mix(v0, v1, u), mix(v3, v2, u), v);
        //gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(mix(v0, v1, prev_u), mix(v3, v2, prev_u), prev_v);
        gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(mix(v0, v1, float(inter_u)), mix(v3, v2, float(inter_u)), float(inter_v));
        //gl_PrimitiveIndicesNV[idx] = idx;

        vec2 uvs[] = {
            vec2 (inter_u, inter_v),
            vec2 (1 - inter_v, inter_u),
            vec2 (1 - inter_u, 1 - inter_v),
            vec2 (inter_v, 1 - inter_u)
        };

        int is_fst_half = int(u_idx < ceil_lvl * 0.5), is_snd_half = int(u_idx >= ceil_lvl * 0.5);

        if (idx == no_bottom_verts - 1) continue;
       
        if (is_snd_half == 1 || is_up == 1) continue;

        int trunc_log_oLvl = int (u_idx > bot_divergent_idx) * int(floor(log_oLvl)) + 
                             int (u_idx <= bot_divergent_idx) * int(ceil(log_oLvl));

        double bottom_top_ratio = pow (2, int(trunc_log_oLvl - floor(log_iuLvl)));

        //int div_verts_offset = 0;
        int div_verts_bot_offset = max(0, int((ceil_oLvl - pow(2, trunc_log_oLvl)) * 0.5));
        int div_verts_top_offset = max(0, int((ceil_iuLvl - pow(2, int(floor(log_iuLvl)))) * 0.5));

        double inter_up = min((ceil_iuLvl - 2) * 0.5, double(u_idx - div_verts_bot_offset) / bottom_top_ratio);

        bottom_top_ratio /= int(floor(log_iuLvl) != ceil(log_iuLvl)) * int(floor(inter_up) < ceil(top_divergent_idx * 0.5)) + 1;

        inter_up = min((ceil_iuLvl - 2) * 0.5, double(u_idx - div_verts_bot_offset) / bottom_top_ratio) + 
                   int(floor(inter_up) >= ceil(top_divergent_idx * 0.5)) * div_verts_top_offset;

        int f_inter_idx = is_down * (no_bottom_verts + int(floor(inter_up)) - min_u_top + 1); 
        int c_inter_idx = is_down * (no_bottom_verts + int(ceil(inter_up)) - min_u_top + 1); 
        int r_inter_idx = is_down * (no_bottom_verts + int(round(inter_up)) - min_u_top + 1); 

        gl_PrimitiveIndicesNV[idx * 9 + 0] = idx + is_up;
        gl_PrimitiveIndicesNV[idx * 9 + 1] = idx + is_down;
        gl_PrimitiveIndicesNV[idx * 9 + 2] = f_inter_idx;
        //gl_PrimitiveIndicesNV[idx * 9 + 2] = idx + is_down;
        
        p_out[3 * idx + 0].mesh_id = 0;
        p_out[3 * idx + 0].divs = 3;

        gl_PrimitiveIndicesNV[idx * 9 + 3] = idx + is_up;
        gl_PrimitiveIndicesNV[idx * 9 + 4] = idx + is_down;
        //gl_PrimitiveIndicesNV[idx * 9 + 5] = c_inter_idx;
        gl_PrimitiveIndicesNV[idx * 9 + 5] = idx + is_down;

        p_out[3 * idx + 1].mesh_id = 3;
        p_out[3 * idx + 1].divs = 12;

        gl_PrimitiveIndicesNV[idx * 9 + 6] = idx + is_up;
        gl_PrimitiveIndicesNV[idx * 9 + 7] = idx + is_down;
        //gl_PrimitiveIndicesNV[idx * 9 + 8] = r_inter_idx;
        gl_PrimitiveIndicesNV[idx * 9 + 8] = idx + is_down;

        p_out[3 * idx + 2].mesh_id = 2;
        p_out[3 * idx + 2].divs = 3;

    }

    //int no_prims = no_verts;
    //int no_prims = no_bottom_verts - 1;
    int no_prims = 3 * (no_bottom_verts + no_top_verts - 1);

    // No. Primitives
    gl_PrimitiveCountNV = no_prims;

}
