#version 460
#extension GL_NV_mesh_shader : enable
 
layout(local_size_x=32) in;
layout(triangles, max_vertices=256, max_primitives=512) out;
//layout(points, max_vertices=256, max_primitives=512) out;

taskNV in perTaskData {
  uint divs;
};

//perprimitiveNV out PerPrimitiveData 
//{
  //uint divs;
  //uint mesh_id;
//} p_out[]; 

out perVertexData
{
    vec2 texCoordTE;
} v_out[];

uniform mat4 m_pvm;

uniform vec3 disp;

uniform float irows;
uniform float icols;

layout(std430, binding = 1) readonly buffer verticesBuffer
{
    float vertices[];
};

void main()
{
    // Inputs
    uint local_id  = gl_LocalInvocationID.x;
    uint global_id  = gl_GlobalInvocationID.x;
    uint workg_id = gl_WorkGroupID.x;
    uint workg_len = gl_WorkGroupSize.x;

    // Quad vertices
    vec4 v0 = vec4(disp + vec3 (vertices[0 * 3 + 1], 
                                vertices[0 * 3 + 2], 
                                vertices[0 * 3 + 3]), 1.0);
    vec4 v1 = vec4(disp + vec3 (vertices[1 * 3 + 1], 
                                vertices[1 * 3 + 2], 
                                vertices[1 * 3 + 3]), 1.0);
    vec4 v2 = vec4(disp + vec3 (vertices[2 * 3 + 1], 
                                vertices[2 * 3 + 2], 
                                vertices[2 * 3 + 3]), 1.0);
    vec4 v3 = vec4(disp + vec3 (vertices[3 * 3 + 1], 
                                vertices[3 * 3 + 2], 
                                vertices[3 * 3 + 3]), 1.0);

    // Tessellation Levels
    int ceil_cols = int(ceil(icols));
    ceil_cols += ceil_cols % 2;
    int ceil_rows = int(ceil(irows));
    ceil_rows += ceil_rows % 2;

    int workg_u_id = int(workg_id % divs);
    int workg_v_id = int(workg_id / divs);

    int min_u_idx = int(max( 1.0, round( mix( 1.0, float(ceil_cols - 1), float(workg_u_id) / float(divs)))));
    int max_u_idx = int(min( ceil_cols - 1, round( mix( 1.0, float(ceil_cols - 1), float(workg_u_id + 1) / float(divs)))));
    int min_v_idx = int(max( 1.0, round( mix( 1.0, float(ceil_rows - 1), float(workg_v_id) / float(divs)))));
    int max_v_idx = int(min( ceil_rows - 1, round( mix( 1.0, float(ceil_rows - 1), float(workg_v_id + 1) / float(divs)))));

    int no_cols = max_u_idx - min_u_idx;
    int no_lines = max_v_idx - min_v_idx;
    int no_verts = (no_cols + 1) * (no_lines + 1);

    for (int i=0; i <= no_verts / workg_len; i++) {

        int idx = int(min(i * workg_len + local_id, no_verts - 1));

        int u_idx = min_u_idx + idx % int(no_cols + 1);
        int v_idx = min_v_idx + idx / int(no_cols + 1);

        //uint prev_u_idx = u_idx - 1 - int(u_idx == ceil_cols - 1) * 1 + int(u_idx == 1) * 1;
        //uint prev_v_idx = v_idx - 1 - int(v_idx == ceil_rows - 1) * 1 + int(v_idx == 1) * 1;
        uint prev_u_idx = max(1, min(ceil_cols - 3, int(round(mix(0, ceil_cols - 2, float(u_idx) / float(ceil_cols))))));
        uint prev_v_idx = max(1, min(ceil_rows - 3, int(round(mix(0, ceil_rows - 2, float(v_idx) / float(ceil_rows))))));

        float u = float(u_idx) / float(ceil_cols);
        float prev_u = float(prev_u_idx) / float(max(1, ceil_cols - 2));
        float v = float(v_idx) / float(ceil_rows);
        float prev_v = float(prev_v_idx) / float(max(1, ceil_rows - 2));

        //float inter_u = mix (prev_u, u, 1 - int(icols >= 2) * 0.5 * (ceil_cols - icols));
        //float inter_v = mix (prev_v, v, 1 - int(irows >= 2) * 0.5 * (ceil_rows - irows));
        float inter_u = mix (prev_u, u, 1 - int(icols >= 2) * 0.5 * (ceil_cols - icols));
        float inter_v = mix (prev_v, v, 1 - int(irows >= 2) * 0.5 * (ceil_rows - irows));

        //gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(mix(v0, v1, u), mix(v3, v2, u), v);
        //gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(mix(v0, v1, prev_u), mix(v3, v2, prev_u), prev_v);
        gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(mix(v0, v1, inter_u), mix(v3, v2, inter_u), inter_v);
        //gl_PrimitiveIndicesNV[idx] = idx;

        v_out[idx].texCoordTE = vec2(inter_u, inter_v);
        //p_out[idx].mesh_id = workg_id;
        //p_out[idx].divs = divs * divs;
    }

    int no_prims = (no_cols) * (no_lines) * 2;

    for (int i=0; i <= no_prims / workg_len; i++) {

        int idx = int(min(i * workg_len + local_id, no_prims - 1));

        int u_idx = (idx / 2) % (no_cols);
        int v_idx = (idx / 2) / (no_cols);

        gl_PrimitiveIndicesNV[idx * 3 + 0] = v_idx * (no_cols + 1) + u_idx;
        gl_PrimitiveIndicesNV[idx * 3 + 1] = (v_idx + 1 * idx % 2) * (no_cols + 1) + u_idx + 1;
        gl_PrimitiveIndicesNV[idx * 3 + 2] = (v_idx + 1) * (no_cols + 1) + u_idx + 1 * (1 - idx % 2);

        //p_out[idx].mesh_id = workg_id;
        //p_out[idx].divs = divs * divs;

    }

    // No. Primitives
    gl_PrimitiveCountNV = no_prims;

}
