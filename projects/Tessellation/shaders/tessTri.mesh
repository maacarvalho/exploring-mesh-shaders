#version 460
#extension GL_NV_mesh_shader : enable
 
layout(local_size_x=32) in;
layout(triangles, max_vertices=256, max_primitives=512) out;

uniform mat4 m_pvm;

uniform vec3 disp;

uniform float ilevel;
uniform float olevel;

layout(std430, binding = 1) readonly buffer verticesBuffer
{
    float vertices[];
};

void main()
{
    // Inputs
    uint local_id  = gl_LocalInvocationID.x;
    uint global_id  = gl_GlobalInvocationID.x;
    uint workg_id = gl_WorkGroupID.x;
    uint workg_len = gl_WorkGroupSize.x;

    // Tessellation Levels
    int i_ceil_odd = int(ceil(ilevel));
    i_ceil_odd += 1 - i_ceil_odd % 2;
    int o_ceil_odd = int(ceil(olevel));
    o_ceil_odd += 1 - o_ceil_odd % 2;

    int i_u_lvls = i_ceil_odd - 2;
    int o_u_lvls = o_ceil_odd;
    int v_lvls = int(ceil(0.5 * i_ceil_odd));

    // Triangle vertices
    int side_idx = int(workg_id);

    //if (side_idx != 0) return;

    int v0_idx = side_idx * 3;
    int v1_idx = (side_idx + 1) % 3 * 3;
    int v2_idx = (side_idx + 2) % 3 * 3;
    
    vec4 v0 = vec4(disp + vec3 (vertices[v0_idx + 1], 
                                vertices[v0_idx + 2], 
                                vertices[v0_idx + 3]), 1.0);
    vec4 v1 = vec4(disp + vec3 (vertices[v1_idx + 1], 
                                vertices[v1_idx + 2], 
                                vertices[v1_idx + 3]), 1.0);
    vec4 v2 = vec4(disp + vec3 (vertices[v2_idx + 1], 
                                vertices[v2_idx + 2], 
                                vertices[v2_idx + 3]), 1.0);

    // Triangle center
    vec4 center = (v0 + v1 + v2) / 3.0;

    // "Vertical" tessellation
    float max_v_tess = max(0, float(v_lvls - 1.0) / float(v_lvls - 0.5));
    float prev_max_v_tess = max(0, float(v_lvls - 2.0) / float(v_lvls - 1.5));

    float v_step = 1.0 / (max(v_lvls, 2) - 1);
    float prev_v_step = 1.0 / (max(v_lvls - 1, 2) - 1);

    int no_verts = (o_u_lvls + 1) + v_lvls * (v_lvls - 1);
    for (int i=0; i <= no_verts / workg_len; i++) {

        uint idx = min (i * workg_len + local_id, no_verts - 1);

        int line_idx = 0, col_idx = int(idx); 
        for (int j=v_lvls; j>=1; j--) {
            int line_cols = int(line_idx == 0) * (o_u_lvls + 1) + int(line_idx != 0) * j * 2;
            if (col_idx / line_cols > 0) {

                line_idx++;
                col_idx -= line_cols;
            
            } else break;
        }

        float v = line_idx * mix (0, max_v_tess, v_step);
        float prev_v = min(line_idx, max(0, v_lvls - 2)) * mix(0, prev_max_v_tess, prev_v_step);

        float inter_v = mix (prev_v, v, 1 - (i_ceil_odd - ilevel) * 0.5);

        vec4 inter_v_v0 = mix (v0, center, inter_v);
        vec4 inter_v_v1 = mix (v1, center, inter_v);

        int u_lvls = int(line_idx == 0) * o_u_lvls + int(line_idx != 0) * (i_u_lvls - 2 * (line_idx - 1));

        uint prev_idx = col_idx - 1;
        prev_idx -= int(col_idx == u_lvls) * 1;
        prev_idx += int(col_idx == 0) * 1;

        float u = float(col_idx) / float(u_lvls);
        float prev_u = int(u_lvls != 1) * float(prev_idx) / float(u_lvls - 2) + 
                       int(u_lvls == 1) * u;

        float inter_u = mix (prev_u, u, 1 - 0.5 * (
                float(line_idx == 0) * (o_ceil_odd - olevel) + 
                float(line_idx != 0) * (i_ceil_odd - ilevel)));

        //gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(inter_v_v0, inter_v_v1, u);
        //gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(inter_v_v0, inter_v_v1, prev_u);
        gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(inter_v_v0, inter_v_v1, inter_u);
        //gl_PrimitiveIndicesNV[idx] = idx;

    }
        
    float v = (v_lvls - 1) * mix (0, max_v_tess, v_step);
    float prev_v = min(v_lvls - 1, max(0, v_lvls - 2)) * mix(0, prev_max_v_tess, prev_v_step);

    float inter_v = mix (prev_v, v, 1 - (i_ceil_odd - ilevel) * 0.5);

    gl_MeshVerticesNV[no_verts].gl_Position = m_pvm * mix(v2, center, inter_v);
    //gl_PrimitiveIndicesNV[no_verts] = no_verts;

    // Primitives
    int no_primitives = o_u_lvls + 1 + v_lvls * (v_lvls - 1);
    //int no_primitives = o_u_lvls + i_u_lvls - 2 + (v_lvls - 1) * (v_lvls - 2) * 2;
    for (int i=0; i<= no_primitives / workg_len; i++) {

        uint idx = min (i * workg_len + local_id, no_primitives - 1);

        int line_idx = 0, col_idx = int(idx); 
        int line_cols, offset = 0;
        for (int j=v_lvls; j>=1; j--) {
            line_cols = int(line_idx == 0) * o_u_lvls + int(line_idx != 0) * (j * 2 - 1);
            if (col_idx / line_cols > 0) {

                line_idx++;
                col_idx -= line_cols;
                offset += line_cols + 1;
            
            } else break;
        }

        gl_PrimitiveIndicesNV[idx * 3 + 0] = offset + col_idx;
        gl_PrimitiveIndicesNV[idx * 3 + 1] = offset + col_idx + 1;
        gl_PrimitiveIndicesNV[idx * 3 + 2] = offset + col_idx + line_cols + int(col_idx < line_cols * 0.5);
 
    }

    int old_no_primitives = no_primitives;
    no_primitives = (v_lvls - 1) * (v_lvls - 2);
    for (int i=0; i<= no_primitives / workg_len; i++) {

        uint idx = min (i * workg_len + local_id, no_primitives - 1);

        int line_idx = 0, col_idx = int(idx); 
        int line_cols, offset = 0;
        for (int j=v_lvls; j>=1; j--) {
            line_cols = int(line_idx == 0) * o_u_lvls + int(line_idx != 0) * (j * 2 - 1);
            if (col_idx / line_cols > 0) {

                line_idx++;
                col_idx -= line_cols;
                offset += line_cols + 1;
            
            } else break;
        }

        gl_PrimitiveIndicesNV[(old_no_primitives + idx) * 3 + 0] = offset + col_idx + 1;
        gl_PrimitiveIndicesNV[(old_no_primitives + idx) * 3 + 1] = offset + col_idx;
        gl_PrimitiveIndicesNV[(old_no_primitives + idx) * 3 + 2] = offset + col_idx;
 
    }

    // No. Primitives
    gl_PrimitiveCountNV = 512;

}
