#version 460
#extension GL_NV_mesh_shader : enable
 
layout(local_size_x=1) in;
layout(lines, max_vertices=256, max_primitives=512) out;

uniform mat4 m_pvm;

uniform vec3 disp;

uniform float ilevel;
uniform float olevel;

layout(std430, binding = 1) readonly buffer verticesBuffer
{
    float vertices[];
};

void main()
{
    // Inputs
    uint local_id  = gl_LocalInvocationID.x;
    uint global_id  = gl_GlobalInvocationID.x;
    uint workg_id = gl_WorkGroupID.x;
    uint workg_len = gl_WorkGroupSize.x;

    // Tessellation Levels
    int i_ceil_odd = int(ceil(ilevel));
    i_ceil_odd += 1 - i_ceil_odd % 2;
    int o_ceil_odd = int(ceil(olevel));
    o_ceil_odd += 1 - o_ceil_odd % 2;

    int i_u_lvls = i_ceil_odd - 2;
    int o_u_lvls = o_ceil_odd;
    int v_lvls = int(ceil(0.5 * i_ceil_odd));

    // Triangle vertices
    int side_idx = int(workg_id) / v_lvls;

    int v0_idx = side_idx * 3;
    int v1_idx = (side_idx + 1) % 3 * 3;
    int v2_idx = (side_idx + 2) % 3 * 3;
    
    // No. Primitives
    //uint prim_count = uint(vertices[0]);

    vec4 v0 = vec4(disp + vec3 (vertices[v0_idx + 1], 
                                vertices[v0_idx + 2], 
                                vertices[v0_idx + 3]), 1.0);
    vec4 v1 = vec4(disp + vec3 (vertices[v1_idx + 1], 
                                vertices[v1_idx + 2], 
                                vertices[v1_idx + 3]), 1.0);
    vec4 v2 = vec4(disp + vec3 (vertices[v2_idx + 1], 
                                vertices[v2_idx + 2], 
                                vertices[v2_idx + 3]), 1.0);

    // Triangle center
    vec4 center = (v0 + v1 + v2) / 3.0;

    // "Vertical" tessellation
    float max_v_tess = max(0, float(v_lvls - 1.0) / float(v_lvls - 0.5));
    float prev_max_v_tess = max(0, float(v_lvls - 2.0) / float(v_lvls - 1.5));

    float v_step = 1.0 / (max(v_lvls, 2) - 1);
    float prev_v_step = 1.0 / (max(v_lvls - 1, 2) - 1);

    int line_idx = int(workg_id) % v_lvls;
    float v = line_idx * mix (0, max_v_tess, v_step);
    float prev_v = min(line_idx, max(0, v_lvls - 2)) * mix(0, prev_max_v_tess, prev_v_step);

    float inter_v = mix (prev_v, v, 1 - (i_ceil_odd - ilevel) * 0.5);

    //gl_MeshVerticesNV[0].gl_Position = m_pvm * v0_center;
    //gl_MeshVerticesNV[1].gl_Position = m_pvm * v1_center;
    //
    //gl_MeshVerticesNV[0].gl_Position = m_pvm * mix(v0, center, v);
    //gl_MeshVerticesNV[1].gl_Position = m_pvm * mix(v1, center, v);

    //gl_MeshVerticesNV[0].gl_Position = m_pvm * mix(v0, center, prev_v);
    //gl_MeshVerticesNV[1].gl_Position = m_pvm * mix(v1, center, prev_v);

    gl_MeshVerticesNV[0].gl_Position = m_pvm * mix(v0, center, inter_v);
    gl_MeshVerticesNV[1].gl_Position = m_pvm * mix(v1, center, inter_v);
            
    gl_PrimitiveIndicesNV[0] = 0;
    gl_PrimitiveIndicesNV[1] = 1;

    // Primitives
    gl_PrimitiveCountNV = 512;

}
