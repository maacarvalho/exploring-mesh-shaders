#version 460
#extension GL_NV_mesh_shader : enable
 
layout(local_size_x=32) in;
layout(triangles, max_vertices=256, max_primitives=512) out;

uniform mat4 m_pvm;

uniform vec3 disp;

uniform float ilevel;
uniform float olevel;

layout(std430, binding = 1) readonly buffer verticesBuffer
{
    float vertices[];
};

void main()
{
    // Inputs
    uint local_id  = gl_LocalInvocationID.x;
    uint global_id  = gl_GlobalInvocationID.x;
    uint workg_id = gl_WorkGroupID.x;
    uint workg_len = gl_WorkGroupSize.x;

    // Tessellation Levels
    int i_ceil_odd = int(ceil(ilevel));
    i_ceil_odd += 1 - i_ceil_odd % 2;
    int o_ceil_odd = int(ceil(olevel));
    o_ceil_odd += 1 - o_ceil_odd % 2;

    int i_u_lvls = i_ceil_odd - 2;
    int o_u_lvls = o_ceil_odd;
    int v_lvls = int(ceil(0.5 * i_ceil_odd));

    // Triangle vertices
    int side_idx = int(workg_id) / v_lvls;

    int v0_idx = side_idx * 3;
    int v1_idx = (side_idx + 1) % 3 * 3;
    int v2_idx = (side_idx + 2) % 3 * 3;
    
    // No. Primitives
    //uint prim_count = uint(vertices[0]);

    vec4 v0 = vec4(disp + vec3 (vertices[v0_idx + 1], 
                                vertices[v0_idx + 2], 
                                vertices[v0_idx + 3]), 1.0);
    vec4 v1 = vec4(disp + vec3 (vertices[v1_idx + 1], 
                                vertices[v1_idx + 2], 
                                vertices[v1_idx + 3]), 1.0);
    vec4 v2 = vec4(disp + vec3 (vertices[v2_idx + 1], 
                                vertices[v2_idx + 2], 
                                vertices[v2_idx + 3]), 1.0);

    // Triangle center
    vec4 center = (v0 + v1 + v2) / 3.0;

    // "Vertical" tessellation
    float max_v_tess = max(0, float(v_lvls - 1.0) / float(v_lvls - 0.5));
    float prev_max_v_tess = max(0, float(v_lvls - 2.0) / float(v_lvls - 1.5));

    float v_step = 1.0 / (max(v_lvls, 2) - 1);
    float prev_v_step = 1.0 / (max(v_lvls - 1, 2) - 1);

    int line_idx = int(workg_id) % v_lvls;

    //if (line_idx != 0) return;

    // Bottom Line
    float v = line_idx * mix (0, max_v_tess, v_step);
    float prev_v = min(line_idx, max(0, v_lvls - 2)) * mix(0, prev_max_v_tess, prev_v_step);

    float inter_v = mix (prev_v, v, 1 - (i_ceil_odd - ilevel) * 0.5);

    vec4 inter_v_v0 = mix (v0, center, inter_v);
    vec4 inter_v_v1 = mix (v1, center, inter_v);
    vec4 inter_v_v2 = mix (v2, center, inter_v);

    int u_lvls = int(line_idx == 0) * o_u_lvls + int(line_idx != 0) * (i_u_lvls - 2 * (line_idx - 1));

    for (int i=0; i <= (u_lvls - 1) / workg_len; i++) {

        uint idx = min (i * workg_len + local_id + 1, u_lvls - 1);
        float middle_idx = u_lvls * 0.5;
        uint prev_idx = idx - (1 * int(abs(idx - middle_idx) < 1) + 2 * int(idx - middle_idx > 1));

        float u = float(idx) / float(u_lvls);
        float prev_u = float(prev_idx) / float(u_lvls - 2);

        float inter_u = mix (prev_u, u, 1 - 0.5 * 
                (int(line_idx == 0) * (o_ceil_odd - olevel) + int(line_idx != 0) * (i_ceil_odd - ilevel)));
        //float inter_u = mix (prev_u, u, 1 - 0.5);

        //gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(inter_v_v0, inter_v_v1, u);
        //gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(inter_v_v0, inter_v_v1, prev_u);
        gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(inter_v_v0, inter_v_v1, inter_u);
        //gl_PrimitiveIndicesNV[idx] = idx;

    }
    gl_MeshVerticesNV[0].gl_Position = m_pvm * inter_v_v0;
    //gl_PrimitiveIndicesNV[0] = 0;
    gl_MeshVerticesNV[u_lvls].gl_Position = m_pvm * inter_v_v1;
    //gl_PrimitiveIndicesNV[u_lvls] = u_lvls;

    // Top Line
    //int vert_offset = 0;
    int vert_offset = u_lvls + 1;

    line_idx = min(line_idx + 1, v_lvls - 1);
    v = line_idx * mix (0, max_v_tess, v_step);
    prev_v = min(line_idx, max(0, v_lvls - 2)) * mix(0, prev_max_v_tess, prev_v_step);

    inter_v = mix (prev_v, v, 1 - (i_ceil_odd - ilevel) * 0.5);

    inter_v_v0 = mix (v0, center, inter_v);
    inter_v_v1 = mix (v1, center, inter_v);

    u_lvls = i_u_lvls - 2 * (line_idx - 1);

    for (int i=0; i <= (u_lvls - 1) / workg_len; i++) {

        uint idx = min (i * workg_len + local_id + 1, u_lvls - 1);
        float middle_idx = u_lvls * 0.5;
        uint prev_idx = idx - (1 * int(abs(idx - middle_idx) < 1) + 2 * int(idx - middle_idx > 1));

        float u = float(idx) / float(u_lvls);
        float prev_u = float(prev_idx) / float(u_lvls - 2);

        float inter_u = mix (prev_u, u, 1 - 0.5 * (i_ceil_odd - ilevel));
        //float inter_u = mix (prev_u, u, 1 - 0.5);

        //gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(inter_v_v0, inter_v_v1, u);
        //gl_MeshVerticesNV[idx].gl_Position = m_pvm * mix(inter_v_v0, inter_v_v1, prev_u);
        gl_MeshVerticesNV[vert_offset + idx].gl_Position = m_pvm * mix(inter_v_v0, inter_v_v1, inter_u);
        //gl_PrimitiveIndicesNV[vert_offset + idx] = idx;

    }

    bool inside_triangle = vert_offset == 2 && line_idx == v_lvls - 1;

    gl_MeshVerticesNV[vert_offset + 0].gl_Position = m_pvm * (
        int(inside_triangle) * inter_v_v2 + int(!inside_triangle) * inter_v_v0);
    gl_MeshVerticesNV[vert_offset + u_lvls].gl_Position = m_pvm * (
        int(inside_triangle) * inter_v_v2 + int(!inside_triangle) * inter_v_v1);


    // Primitives
    gl_PrimitiveIndicesNV[0] = 0;
    gl_PrimitiveIndicesNV[1] = 1;
    gl_PrimitiveIndicesNV[2] = vert_offset;

    for (int i=0; i<= (u_lvls - 1) / workg_len; i++) {

        uint idx = min (i * workg_len + local_id + 1, u_lvls);

        gl_PrimitiveIndicesNV[3 + (idx - 1) * 6 + 0] = idx;
        gl_PrimitiveIndicesNV[3 + (idx - 1) * 6 + 1] = idx + 1;
        gl_PrimitiveIndicesNV[3 + (idx - 1) * 6 + 2] = vert_offset + idx;
        
        gl_PrimitiveIndicesNV[3 + (idx - 1) * 6 + 3] = idx;
        gl_PrimitiveIndicesNV[3 + (idx - 1) * 6 + 4] = vert_offset + idx;
        gl_PrimitiveIndicesNV[3 + (idx - 1) * 6 + 5] = vert_offset + idx - 1;

    }

    gl_PrimitiveIndicesNV[3 + u_lvls * 6 + 0] = vert_offset - 2;
    gl_PrimitiveIndicesNV[3 + u_lvls * 6 + 1] = vert_offset - 1;
    gl_PrimitiveIndicesNV[3 + u_lvls * 6 + 2] = vert_offset + u_lvls;

    // No. Primitives
    gl_PrimitiveCountNV = 512;

}
